# 概述
设计模式：在面向对象软件设计过程中针对特定问题的优雅解决方案,同时也为重构提供了目标。
通过学习设计模式，来提高自身设计和编码能力。设计模式最初是从面向对象设计角度出发，封装、继承、多态、组合的使用，提炼出不同问题的解决方案，设计方案。在javascript中同样适用，但由于动态语言，扩展对象属性很容易，再加上函数是第一公民下，javascript天然的实现了多种设计模式。
体会：
1. 熟悉javascript的语言特性：函数传递、this、proxy、decorate、DOM事件机制、回调、闭包、高阶、科里化、原型链委托。
2. 要保持面向对象意识，谨记设计原则。将做什么和谁去做和怎么做进行分离。__关注对象的行为，而不关注对象的本身。__ 又注意在javascript语言中，函数是第一公民，适当变通运用。
3. 只有通过深刻理解模式意图再结合业务场景，才能灵活运用，而非生搬硬套，手里有锤子，一切为钉子。
# 基础知识
> 封装、继承、多态、组合
## 封装
封装的目的是将信息隐藏，封装数据、封装实现、封装类型、封装变化。
### 封装数据
#### 作用域的封装 块级作用域 闭包
#### 对象属性的封装 Object.definePrototype
#### 模块的封装 moudle Class 原型链  几种方式 对象委托
- 原型模式 委托 对象引用
### 封装变化
- 创建型，封装创建对象的行为。
> 
- 结构型，封装对象与对象之间的组合关系。
- 行为型，封装对象的行为变化。
关注对象行为而非对象本身，分离谁来做，做什么和怎么做。通过理解意图，识别场景使用不同模式。
## 多态
相同的命令，不同对象的调用，产生的结果不同。这种分离谁来做，做什么关键在于消除类型约束，由于javascript是动态语言，天生具备多态性，不必进行向上转型。

## 技巧

## 设计原则
单一原则，开闭原则，依赖倒置，最少知识，接口隔离、合成复用、里式替换
## ES 语言特性
### 创建对象的方法
Object.create()
    解决原型链上元素同名问题, Object.create(null)
{}
### 对象属性操作
Object.defineProperty
Object.getOwnPropertyDescriptor
Object.keys()
> 必须将enumerable设置为true才能获取，否则返回是空数组
propertyIsEnumerable 是否可枚举
hasOwnProperty 是否含有特定属性
> - 和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
> - 如果继承的对象属性是通过Object.defineProperty创建的，并且enumerable未设置成true，那么for in依然不能枚举出原型上的属性。

__proto__

Object.preventExtensions
方法用于锁住对象属性，使其不能够拓展，也就是不能增加新的属性，但是属性的值仍然可以更改.

Object.isExtensible

Object.seal

让对象既不可以拓展也不可以删除属性（把每个属性的configurable设为false）

Object.isSealed 
判断对象是否被密封

Object.freeze完全冻结对象，
在seal的基础上，属性值也不可以修改（每个属性的wirtable也被设为false

Object.isFrozen判断对象是否被冻结

### DOM 自定义事件
cloneNode
document.activeElement是当前获得焦点的元素，可以使用document.hasFocus()方法来查看当前元素是否获取焦点。

document.createEvent()

event.initEvent()

element.dispatchEvent()
| 参数 | 事件接口 | 初始化方法 |
| ------ | ------ | ------ |
| HTMLEvents | HTMLEvent | initEvent() |
| MouseEvents | MouseEvent | initMouseEvent() |
| UIEvents | UIEvent | initUIEvent() |

initEvent(eventName, canBubble, preventDefault)

getBoundingClientRect 
window.pageXOffset 和 window.pageYOffset 代替 window.scrollX 和 window.scrollY。
// For scrollX
(((t = document.documentElement) || (t = document.body.parentNode))
  && typeof t.scrollLeft == 'number' ? t : document.body).scrollLeft
// For scrollY
(((t = document.documentElement) || (t = document.body.parentNode))
  && typeof t.scrollTop == 'number' ? t : document.body).scrollTop
clientTop clientLeft
### 基础
假值: false，null，0，""，undefined，NaN
Math操作:
~~
取整: |
判断奇偶数 & 1
### 性能
window.performance
performance.mark
performance.measure
https://www.w3.org/TR/navigation-timing/
### Proxy
### with 
### 数组变异和非变异操作
# 耦合
耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：
（1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。
（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
（5） 标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。
（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。
总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。
# 分类
- 创建型，封装创建对象的行为。
> 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
- 结构型，封装对象与对象之间的组合关系。
> 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型，封装对象的行为变化。
> 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。